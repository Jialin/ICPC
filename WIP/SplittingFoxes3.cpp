#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

#include "graphs/forward_star/unweighted_forward_star.h"
#include "graphs/topological_sorter.h"
#include "math/mod/add.h"
#include "math/mod/exp.h"
#include "math/mod/log_coprime.h"
#include "math/mod/sub.h"

const int MAXN = 300;

bool reachable[MAXN][MAXN];

class SplittingFoxes3 {
public:
  const int MOD = 1000000007;

  graphs::UnweightedForwardStar graph;
  graphs::TopologicalSorter tsorter;
  math::LogModCoPrime<> logMod;

  vector<int>
  restore(int n, int foxCnt, vector<int> a, vector<int> b, vector<int> x) {
    logMod.init(100003);
    memset(reachable, 0, sizeof(reachable));
    for (int i = 0; i < n; ++i) {
      reachable[i][i] = true;
    }
    int m = static_cast<int>(a.size());
    graph.init(n, m);
    for (int i = 0; i < m; ++i) {
      graph.addDirected(a[i], b[i]);
      reachable[a[i]][b[i]] = true;
    }
    for (int k = 0; k < n; ++k) {
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
          reachable[i][j] |= reachable[i][k] && reachable[k][j];
        }
      }
    }
    vector<int> orders;
    if (!tsorter.calc(graph, [&orders](int u) { orders.push_back(u); })) {
      return {};
    }
    vector<int> answers;
    answers.assign(n, 0);
    for (int u : orders) {
      int subRes;
      DEBUG("u:%d foxCnt:%d x:%d\n", u, foxCnt, x[u]);
      if (!logMod.calc(foxCnt, x[u], MOD, subRes)) {
        return {};
      }
      DEBUG("\tsubRes:%d\n", subRes);
      answers[u] = math::addMod(answers[u], subRes, MOD);
      for (int i = 0; i < n; ++i) {
        if (reachable[u][i]) {
          x[i] = math::addMod(x[i], x[u], MOD);
          answers[i] = math::subMod(answers[i], subRes, MOD);
        }
      }
    }
    return answers;
  }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(
    int testNum,
    int p0,
    int p1,
    vector<int> p2,
    vector<int> p3,
    vector<int> p4,
    bool hasAnswer,
    vector<int> p5) {
  cout << "Test " << testNum << ": [" << p0 << "," << p1 << ","
       << "{";
  for (int i = 0; int(p2.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p2[i];
  }
  cout << "}"
       << ","
       << "{";
  for (int i = 0; int(p3.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p3[i];
  }
  cout << "}"
       << ","
       << "{";
  for (int i = 0; int(p4.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p4[i];
  }
  cout << "}";
  cout << "]" << endl;
  SplittingFoxes3* obj;
  vector<int> answer;
  obj = new SplittingFoxes3();
  clock_t startTime = clock();
  answer = obj->restore(p0, p1, p2, p3, p4);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds"
       << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t"
         << "{";
    for (int i = 0; int(p5.size()) > i; ++i) {
      if (i > 0) {
        cout << ",";
      }
      cout << p5[i];
    }
    cout << "}" << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t"
       << "{";
  for (int i = 0; int(answer.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << answer[i];
  }
  cout << "}" << endl;
  if (hasAnswer) {
    if (answer.size() != p5.size()) {
      res = false;
    } else {
      for (int i = 0; int(answer.size()) > i; ++i) {
        if (answer[i] != p5[i]) {
          res = false;
        }
      }
    }
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  } else if (hasAnswer) {
    cout << "Match :-)" << endl;
  } else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}
int main() {
  bool all_right;
  all_right = true;

  int p0;
  int p1;
  vector<int> p2;
  vector<int> p3;
  vector<int> p4;
  vector<int> p5;

  {
    // ----- test 0 -----
    p0 = 3;
    p1 = 2;
    int t2[] = {0, 2};
    p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
    int t3[] = {1, 1};
    p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
    int t4[] = {1, 2, 1};
    p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
    int t5[] = {1, 0, 1};
    p5.assign(t5, t5 + sizeof(t5) / sizeof(t5[0]));
    all_right =
        KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, true, p5) && all_right;
    // ------------------
  }

  // {
  //   // ----- test 1 -----
  //   p0 = 4;
  //   p1 = 3;
  //   int t2[] = {1, 1, 0, 3};
  //   p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
  //   int t3[] = {0, 3, 2, 2};
  //   p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
  //   int t4[] = {7, 1, 49, 7};
  //   p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
  //   int t5[] = {1, 1, 1, 1};
  //   p5.assign(t5, t5 + sizeof(t5) / sizeof(t5[0]));
  //   all_right =
  //       KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, true, p5) && all_right;
  //   // ------------------
  // }

  // {
  //   // ----- test 2 -----
  //   p0 = 1;
  //   p1 = 2;
  //   p2.clear() /*{}*/;
  //   p3.clear() /*{}*/;
  //   int t4[] = {5};
  //   p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
  //   p5.clear() /*{}*/;
  //   all_right =
  //       KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, true, p5) && all_right;
  //   // ------------------
  // }

  // {
  //   // ----- test 3 -----
  //   p0 = 1;
  //   p1 = 2;
  //   p2.clear() /*{}*/;
  //   p3.clear() /*{}*/;
  //   int t4[] = {4};
  //   p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
  //   int t5[] = {1000000005};
  //   p5.assign(t5, t5 + sizeof(t5) / sizeof(t5[0]));
  //   all_right =
  //       KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, true, p5) && all_right;
  //   // ------------------
  // }

  // {
  //   // ----- test 4 -----
  //   p0 = 8;
  //   p1 = 2;
  //   int t2[] = {0, 2, 2, 4, 4, 6, 1, 3, 5};
  //   p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
  //   int t3[] = {1, 1, 3, 3, 5, 5, 7, 7, 7};
  //   p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
  //   int t4[] = {1, 4, 4, 12, 9, 24, 16, 30};
  //   p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
  //   int t5[] = {1, 0, 2, 0, 3, 0, 4, 0};
  //   p5.assign(t5, t5 + sizeof(t5) / sizeof(t5[0]));
  //   all_right =
  //       KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, true, p5) && all_right;
  //   // ------------------
  // }

  // {
  //   // ----- test 5 -----
  //   p0 = 10;
  //   p1 = 1000000000;
  //   int t2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
  //   p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
  //   int t3[] = {0, 0, 2, 3, 3, 2, 5, 4, 7};
  //   p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
  //   int t4[] = {0, 0, 1, 0, 0, 0, 0, 0, 0, 0};
  //   p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
  //   int t5[] = {0, 0, 1, 0, 0, 0, 0, 0, 0, 0};
  //   p5.assign(t5, t5 + sizeof(t5) / sizeof(t5[0]));
  //   all_right =
  //       KawigiEdit_RunTest(5, p0, p1, p2, p3, p4, true, p5) && all_right;
  //   // ------------------
  // }

  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  } else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// END KAWIGIEDIT TESTING
// Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
