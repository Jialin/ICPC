namespace {

{{> floor_div}}

} // namespace

template <typename T> class {{#minmax}}{{cap}}{{/minmax}}ConvexHullTricksAdd{{#incdec}}{{cap}}{{/incdec}} {
private:
  class Line {
  public:
    T a, b, x;

    inline Line(T a_, T b_, T x_) : a(a_), b(b_), x(x_) {}
  };

public:
  inline void init() {
    lines.clear();
  }

  inline void add(T a, T b) {
    static T inf = numeric_limits<T>::{{#frontback}}{{inf}}{{/frontback}}();
    if (lines.empty()) {
      lines.emplace_{{#frontback}}{{v}}{{/frontback}}(a, b, inf);
      return;
    }
    const auto& line = lines.{{#frontback}}{{v}}{{/frontback}}();
    if (line.a == a) {
      if (b {{#minmax}}{{{cmp}}}{{/minmax}} line.b) {
        lines.pop_{{#frontback}}{{v}}{{/frontback}}();
      } else {
        return;
      }
    }
    T x;
    while (true) {
      line = lines.{{#frontback}}{{v}}{{/frontback}}();
      x = floorDiv(b - line.b, line.a - a);
      if (lines.size() == 1 || line.x {{#frontback}}{{{cmp}}}{{/frontback}} x) {
        break;
      }
      lines.pop_{{#frontback}}{{v}}{{/frontback}}();
    }
    lines.emplace_{{#frontback}}{{v}}{{/frontback}}(a, b, x);
  }

  inline int queryLineIdx(T x) {
    return static_cast<int>(
        lower_bound(lines.begin(), lines.end(), x,
                    [](const Line &line, const T x_) { return line.x < x_; }) -
        lines.begin());
  }

  inline T query(T x) {
    assert(!lines.empty());
    const auto& line = lines[queryLineIdx(x)];
    return line.a * x + line.b;
  }

  deque<Line> lines;
};
